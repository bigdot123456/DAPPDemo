# DAPPDemo
玩法


image.png

首先需要安装MetaMask插件，然后刷新页面，点击某个扇区进行下注，下注之前可以看下页面上的信息，如上图所示，顶部显示了当前的奖金池（即过往未中奖的累计奖金），还有当前每一注的大小，注意这两项的单位都是wei，这是以太坊中最小的单位，与以太币的换算关系是1Ether = 10^18wei。右边显示了上轮的中奖情况，玩家可以通过统计每一轮开奖的扇区来计算开奖的规律（笑）。点击扇区下注时页面会弹出一个输入框输入下的注数，确定后将跳出MetaMask交易界面，如下图所示，由于我们每一注比较小，所以玩家可以下多一点注，不然交易的amount近似于0。当我们点击submit按钮后，交易就发生了，由于区块链同步时间较长，我们每次下注大约需要等几十秒左右才能确认下注成功，最后我们等待倒计时结束后系统将开奖。


image.png

架构

整个Demo的架构如下：

前端：JavaScript + MetaMask + Web3.js

后台：Node.js + Web3.js

区块链：Ropsten以太坊测试网络

三者的通信过程如下图所示：


image.png

0.后台启动轮盘倒计时

1.浏览器访问前端页面，向后台获取转盘的配置

2.前端页面启动倒计时

3.用户在前端页面下注，先请求以太坊节点，得到下注成功的返回再通知后台

3.5.后台倒计时时间到，请求以太坊节点，返回当前回合是否成功结束

4.前端倒计时也时间到了，向后台请求当前回合的开奖情况，但由于后台开奖结果需要等待以太坊节点的返回，因此这里需要轮询，要么就改成后台主动push到前端

注意，这里第3步前端下注的时候由于回调时间过长，可能会导致在后台开奖后还没有下注成功，这种情况下DApp应该要回滚这次下注，但这只是个Demo，就不要在意这些细节了。

DApp VS 传统App

讲到这里，相信读者已经清楚以太坊DApp的完整开发流程了，回顾一下这个流程，对于DApp开发和传统App开发的区别，读者总结出以下几点：

前端、后台与数据源解耦，在传统App开发过程中，数据源对于前端来说都是不可见的，只有后台才可以增删改查数据源

调用方式，传统App访问数据源大部分都是靠数据库提供的接口或第三方封装的接口，如JDBC，而DApp中一切访问数据源目前都通过Web3.js，而且还需要考虑手续费和签名问题

调用频率，上面已经提到，以太坊节点访问速度极慢而且还需要手续费，如果不是必要的访问，尽量放到业务服务器，如上面Demo获取转盘的配置的请求就是请求业务后台而不是以太坊节点

不存在不确定代码，也就是DApp所有合约的代码都是客观的，所有节点执行，执行多少次都是一样的结果，例如转盘大富翁Demo中，中奖的扇区号码是业务后台随机产生的，而不是合约代码，为什么呢，最直接原因是Solidity不提供这样的方法，而最根本的原因是DApp是分布式执行的，如果每个节点都产生一个随机数，就会导致合约执行的最终结果不一致，也就破坏了账本。除此之外，获取一些主观结果也是不行的，例如获取今天是否下大雨的结果，这个“大”智能合约根本无法定义。

总结&思考

目前DApp的开发力度和普及程度还远远不够，在手机App面前如同九牛一毛，即使是去年最火爆的以太猫，平均日活也只有900多，原因笔者认为还是在于门槛太高（需要安装插件，每笔交易时间长，手续费高），希望号称下一代区块链平台的EOS能解决这些根本性问题

